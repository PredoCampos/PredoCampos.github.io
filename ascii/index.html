<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Arte ASCII</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Inter:wght@400;700;900&display=swap');

        :root {
            --background-color: #0A0A0A;
            --surface-color: #1A1A1A;
            --primary-text-color: #F5F5F5;
            --secondary-text-color: #A3A3A3;
            --accent-color: #FFFFFF;
            --border-color: #262626;
            --border-hover-color: #404040;
            --error-color: #ff5555;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color);
            color: var(--primary-text-color);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 2rem;
        }

        #app {
            width: 100%;
            max-width: 1100px;
        }

        .container {
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .app-header {
            padding: 1rem 0;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 900;
            letter-spacing: -1px;
        }

        h2 {
            margin-bottom: 1rem;
            color: var(--secondary-text-color);
            font-size: 1rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .subtitle {
            font-size: 1.1rem;
            color: var(--secondary-text-color);
            margin-top: 0.5rem;
        }

        .upload-area {
            width: 100%;
            background-color: var(--surface-color);
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            transition: border-color 0.2s, background-color 0.2s;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .upload-area:hover {
            border-color: var(--border-hover-color);
            background-color: #202020;
        }

        .upload-label {
            width: 100%;
            height: 100%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: inherit;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--primary-text-color);
        }

        .content-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            align-items: flex-start;
        }

        .content-panel {
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            height: 100%;
        }

        .image-preview-box {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--background-color);
            border-radius: 8px;
            min-height: 300px;
            overflow: hidden;
            position: relative;
            cursor: pointer;
            border: 1px solid transparent;
            transition: border-color 0.2s;
        }

        .image-preview-box:hover {
            border-color: var(--border-hover-color);
        }

        .image-preview-box:hover .image-preview-overlay {
            opacity: 1;
        }

        #image-preview {
            display: block;
            max-width: 100%;
            max-height: 450px;
            object-fit: contain;
            transition: transform 0.3s;
        }

        .image-preview-overlay {
            position: absolute;
            inset: 0;
            background-color: rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-text-color);
            font-weight: 700;
            font-size: 1rem;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .output-container {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--background-color);
            border-radius: 8px;
            min-height: 300px;
            overflow: hidden;
        }

        #output-canvas {
            display: block;
            max-width: 100%;
            height: auto;
            image-rendering: pixelated; /* Ensures crisp characters */
        }

        .controls-container {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            transition: opacity 0.3s;
        }

        .controls-container[disabled] {
            opacity: 0.5;
            pointer-events: none;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 0.75rem;
            text-align: left;
        }

        .control-group label {
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--secondary-text-color);
        }

        .resolution-control {
            display: flex;
            width: 100%;
            align-items: center;
            gap: 1rem;
        }

        .color-controls {
            display: flex;
            width: 100%;
            justify-content: space-between;
            align-items: center;
            background: var(--background-color);
            padding: 0.5rem;
            border-radius: 8px;
        }

        .char-input {
            width: 100%;
            background-color: var(--background-color);
            border: 1px solid var(--border-color);
            color: var(--primary-text-color);
            border-radius: 6px;
            padding: 0.6rem;
            font-family: 'Roboto Mono', monospace;
            font-size: 1rem;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .char-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px var(--accent-color);
        }

        .control-hint {
            font-size: 0.8rem;
            color: var(--secondary-text-color);
            width: 100%;
            text-align: left;
            padding-left: 0.2rem;
        }

        .error-message {
            color: var(--error-color);
            font-weight: bold;
        }

        input[type="number"] {
            width: 65px;
            background-color: var(--background-color);
            border: 1px solid var(--border-color);
            color: var(--primary-text-color);
            border-radius: 6px;
            padding: 0.6rem;
            font-family: 'Roboto Mono', monospace;
            text-align: center;
            font-size: 1rem;
            -moz-appearance: textfield;
        }

        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
          -webkit-appearance: none;
          margin: 0;
        }

        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 36px;
            height: 36px;
            background-color: transparent;
            border: none;
            cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch {
            border-radius: 8px;
            border: 2px solid var(--border-color);
        }
        input[type="color"]::-moz-color-swatch {
            border-radius: 8px;
            border: 2px solid var(--border-color);
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: var(--border-color);
            height: 6px;
            border-radius: 3px;
            outline: none;
            cursor: pointer;
            flex-grow: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--background-color);
            box-shadow: 0 0 0 2px var(--accent-color);
        }

        .button {
            background-color: var(--accent-color);
            color: var(--background-color);
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            font-weight: 700;
            cursor: pointer;
            font-size: 1rem;
            transition: transform 0.2s, background-color 0.2s;
            display: inline-block;
            min-width: 150px; /* Changed from width */
        }

        .button:hover {
            transform: scale(1.03);
        }

        .button:disabled {
            background-color: var(--border-hover-color);
            color: var(--secondary-text-color);
            cursor: not-allowed;
            transform: none;
        }

        .button-icon {
            background: none;
            border: none;
            color: var(--secondary-text-color);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            line-height: 1;
            transition: color 0.2s, transform 0.2s;
        }
        .button-icon:hover {
            color: var(--primary-text-color);
            transform: scale(1.1);
        }

        .progress-container {
            width: 100%;
            background-color: var(--border-color);
            border-radius: 4px;
            height: 4px;
        }

        .progress-bar {
            width: 0%;
            height: 100%;
            background: var(--accent-color);
            border-radius: 4px;
            transition: width 0.1s ease-in-out;
        }

        #advanced-download-wrapper {
            padding-top: 1.5rem;
            margin-top: -0.5rem;
            padding-bottom: 0.5rem;
            border-top: 1px solid var(--border-color);
        }

        #advanced-download-wrapper summary {
            cursor: pointer;
            font-weight: 700;
            color: var(--secondary-text-color);
            list-style: none; /* remove triangle on firefox */
            transition: color 0.2s;
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
        }

        #advanced-download-wrapper summary::-webkit-details-marker {
            display: none; /* remove triangle on chrome/safari */
        }
        #advanced-download-wrapper summary:focus {
            outline: none;
        }

        #advanced-download-wrapper summary:hover {
            color: var(--primary-text-color);
        }

        #advanced-download-wrapper[open] > summary {
            margin-bottom: 1.5rem;
        }

        .download-settings {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .preset-select {
            width: 100%;
            background-color: var(--background-color);
            border: 1px solid var(--border-color);
            color: var(--primary-text-color);
            border-radius: 6px;
            padding: 0.6rem;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .preset-select:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px var(--accent-color);
        }

        .dimension-controls {
            display: flex;
            width: 100%;
            align-items: center;
            gap: 0.5rem;
        }

        .dimension-controls input[type="number"] {
            flex-grow: 1;
            width: auto; /* override fixed width */
        }

        #aspect-ratio-toggle.locked {
            color: var(--accent-color);
        }

        #aspect-ratio-toggle:not(.locked) {
            color: var(--secondary-text-color);
        }


        @media (max-width: 820px) {
            .content-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 600px) {
            body {
                padding: 1rem;
            }
            h1 {
                font-size: 2rem;
            }
        }
    </style>
<script type="importmap">
{
  "imports": {
    "gifuct-js": "https://esm.sh/gifuct-js@^2.1.2",
    "gif.js": "https://esm.sh/gif.js@^0.2.0"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    <main id="app">
        <input type="file" id="image-input" accept="image/*,image/gif" hidden>
        <div class="container">
            <header class="app-header">
                <h1>Gerador de Arte ASCII</h1>
                <p class="subtitle">Transforme qualquer imagem ou GIF em arte.</p>
            </header>

            <div id="content-area" class="content-grid" style="display: none;">
                <div class="content-panel">
                    <h2>Original</h2>
                    <div class="image-preview-box" title="Clique para trocar a imagem">
                        <img id="image-preview" src="" alt="Pré-visualização da imagem original" />
                        <div class="image-preview-overlay">
                            <span>Trocar Imagem</span>
                        </div>
                    </div>
                </div>
                <div class="content-panel">
                    <h2>Arte ASCII</h2>
                    <div id="controls" class="controls-container">
                        <div class="control-group">
                            <label for="resolution-slider">Resolução</label>
                            <div class="resolution-control">
                                <input type="range" id="resolution-slider" min="10" max="200" value="100" title="Ajuste a densidade de caracteres">
                                <input type="number" id="resolution-input" max="200" value="100" title="Valor da resolução">
                            </div>
                            <p id="resolution-error" class="control-hint error-message" style="display: none;"></p>
                        </div>
                        <div class="control-group">
                            <label>Cores e Valores</label>
                            <div class="color-controls">
                                <input type="color" id="bg-color-picker" value="#000000" title="Escolha a cor de fundo">
                                <button id="invert-btn" class="button-icon" title="Inverter Cores">⇆</button>
                                <button id="invert-chars-btn" class="button-icon" title="Inverter Caracteres">⇅</button>
                                <input type="color" id="fg-color-picker" value="#FFFFFF" title="Escolha a cor dos caracteres">
                            </div>
                        </div>
                         <div class="control-group">
                            <label for="char-input">Conjunto de Caracteres</label>
                            <input id="char-input" type="text" class="char-input" title="Edite os caracteres. A ordem será definida pela densidade.">
                            <p class="control-hint">Mínimo de 3 caracteres.</p>
                        </div>
                    </div>
                    <div id="progress-container" class="progress-container" style="display: none;">
                       <div id="progress-bar" class="progress-bar"></div>
                    </div>
                    <div class="output-container">
                       <canvas id="output-canvas" aria-live="polite"></canvas>
                    </div>
                    <details id="advanced-download-wrapper">
                        <summary>Opções Avançadas de Download</summary>
                        <div class="download-settings">
                             <div class="control-group">
                                <label for="download-size-slider">Qualidade da Saída</label>
                                <div class="resolution-control">
                                    <input type="range" id="download-size-slider" min="100" max="3000" value="800" title="Ajuste a dimensão da imagem final">
                                </div>
                            </div>
                            <div class="control-group">
                                <label for="preset-select">Predefinição de Tamanho</label>
                                <select id="preset-select" class="preset-select">
                                    <option value="original">Original</option>
                                    <option value="1280x720">HD (1280x720)</option>
                                    <option value="1920x1080">Full HD (1920x1080)</option>
                                    <option value="3840x2160">4K UHD (3840x2160)</option>
                                    <option value="custom">Personalizado</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label>Dimensões de Saída</label>
                                <div class="dimension-controls">
                                    <input type="number" id="download-width-input" min="1" value="800" title="Largura da imagem de saída">
                                    <button id="aspect-ratio-toggle" class="button-icon locked" title="Manter proporção"></button>
                                    <input type="number" id="download-height-input" min="1" value="600" title="Altura da imagem de saída">
                                </div>
                            </div>
                        </div>
                    </details>
                    <button id="download-btn" class="button"><span>Baixar Arte</span></button>
                </div>
            </div>
            
            <div class="upload-area" id="upload-container">
                <label for="image-input" id="image-upload-label" class="upload-label" role="button" aria-label="Carregar uma imagem ou GIF">
                    <span>Clique para carregar uma imagem ou GIF</span>
                </label>
            </div>
        </div>
    </main>
    <script src="https://unpkg.com/gifuct-js@2.1.2/dist/gifuct-js.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <script>
    window.addEventListener('load', () => {
      // Note: This script was converted from TypeScript.
      
      // DOM element references
      const imageInputElement = document.getElementById('image-input');
      const uploadContainer = document.getElementById('upload-container');
      const imagePreview = document.getElementById('image-preview');
      const imagePreviewBox = document.querySelector('.image-preview-box');
      const contentArea = document.getElementById('content-area');

      const outputCanvas = document.getElementById('output-canvas');
      const controlsContainer = document.getElementById('controls');
      const resolutionSlider = document.getElementById('resolution-slider');
      const resolutionInput = document.getElementById('resolution-input');
      const resolutionError = document.getElementById('resolution-error');
      const bgColorPicker = document.getElementById('bg-color-picker');
      const fgColorPicker = document.getElementById('fg-color-picker');
      const charInputElement = document.getElementById('char-input');

      const downloadBtn = document.getElementById('download-btn');
      const downloadBtnText = downloadBtn.querySelector('span');
      const invertBtn = document.getElementById('invert-btn');
      const invertCharsBtn = document.getElementById('invert-chars-btn');

      const progressContainer = document.getElementById('progress-container');
      const progressBar = document.getElementById('progress-bar');

      const presetSelect = document.getElementById('preset-select');
      const downloadWidthInput = document.getElementById('download-width-input');
      const downloadHeightInput = document.getElementById('download-height-input');
      const aspectRatioToggle = document.getElementById('aspect-ratio-toggle');
      const downloadSizeSlider = document.getElementById('download-size-slider');


      // --- State Variables ---
      const ALPHA_THRESHOLD = 50;
      let USER_ASCII_CHARS = ['.', '<', '>', '/', '1', '0']; 
      let SORTED_ASCII_CHARS = [];

      let currentImage = null;
      let isGif = false;
      let currentGif = null;
      let parsedFrames = [];
      let asciiFrameData = [];
      let animationTimeoutId = null;
      let currentFrameIndex = 0;
      let currentAsciiData = null; // Store data for single image downloads

      let originalAspectRatio = 1;
      let isAspectRatioLocked = true;

      let debounceTimer;
      let charDebounceTimer;

      async function analyzeAndSortChars(chars) {
          const uniqueChars = [...new Set(chars)];
          if (uniqueChars.length === 0) return [];

          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d', { willReadFrequently: true });
          if (!ctx) return uniqueChars;

          const charSize = 24;
          canvas.width = charSize;
          canvas.height = charSize;
          ctx.font = `bold ${charSize}px "Roboto Mono", monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          const charDensities = [];

          for (const char of uniqueChars) {
              ctx.fillStyle = '#000';
              ctx.fillRect(0, 0, charSize, charSize);
              ctx.fillStyle = '#fff';
              ctx.fillText(char, charSize / 2, charSize / 2);

              const imageData = ctx.getImageData(0, 0, charSize, charSize).data;
              let density = 0;
              for (let i = 0; i < imageData.length; i += 4) {
                  if (imageData[i] > 0) density++;
              }
              charDensities.push({ char, density });
          }

          charDensities.sort((a, b) => a.density - b.density);
          return charDensities.map(item => item.char);
      }

      function showProgress(show) {
          progressContainer.style.display = show ? 'flex' : 'none';
          if (show) progressBar.style.width = '0%';
      }

      function updateProgress(percentage) {
          progressBar.style.width = `${percentage}%`;
      }

      /**
       * Processes a single image or frame's pixel data and returns structured ASCII data.
       * @param {CanvasImageSource} imageDataSource - The image or canvas to process.
       * @returns The structured data for drawing.
       */
      function generateAsciiFrameData(imageDataSource) {
          if (SORTED_ASCII_CHARS.length === 0) return null;

          const resolution = parseInt(resolutionSlider.value, 10);
          // Use the source's dimensions, not the potentially different currentImage dimensions
          const sourceWidth = imageDataSource.width;
          const sourceHeight = imageDataSource.height;

          const aspectRatio = sourceWidth / sourceHeight;
          const numCols = resolution;
          const numRows = Math.round((numCols / aspectRatio) * 0.55);

          const offscreenCanvas = document.createElement('canvas');
          offscreenCanvas.width = numCols;
          offscreenCanvas.height = numRows;
          const offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });
          if (!offscreenCtx) return null;

          offscreenCtx.drawImage(imageDataSource, 0, 0, numCols, numRows);
          const currentImageData = offscreenCtx.getImageData(0, 0, numCols, numRows).data;

          const asciiData = [];

          for (let y = 0; y < numRows; y++) {
              for (let x = 0; x < numCols; x++) {
                  const i = (y * numCols + x) * 4;
                  const r = currentImageData[i];
                  const g = currentImageData[i + 1];
                  const b = currentImageData[i + 2];
                  const a = currentImageData[i + 3];

                  let char = '';

                  if (a > ALPHA_THRESHOLD) {
                      const brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                      const charIndex = Math.min(SORTED_ASCII_CHARS.length - 1, Math.floor(brightness * SORTED_ASCII_CHARS.length));
                      const calculatedChar = SORTED_ASCII_CHARS[charIndex];
                      if (calculatedChar) char = calculatedChar;
                  }
                  
                  if (char) {
                      asciiData.push({ char, x, y });
                  }
              }
          }
          return { asciiData, numCols, numRows, aspectRatio };
      }

      function drawAsciiToCanvas(
          targetCanvas, 
          frameData, 
          config
      ) {
          const ctx = targetCanvas.getContext('2d');
          if (!ctx) return;
          
          if (!frameData || !frameData.asciiData || !frameData.aspectRatio) {
              ctx.fillStyle = config.bgColor;
              ctx.fillRect(0, 0, targetCanvas.width, targetCanvas.height);
              return;
          }

          const { asciiData, numCols, numRows, aspectRatio } = frameData;
          const { bgColor, fgColor } = config;

          const canvasW = targetCanvas.width;
          const canvasH = targetCanvas.height;

          ctx.fillStyle = bgColor;
          ctx.fillRect(0, 0, canvasW, canvasH);
          
          let targetW, targetH;
          if ((canvasW / canvasH) > aspectRatio) {
              targetH = canvasH;
              targetW = canvasH * aspectRatio;
          } else {
              targetW = canvasW;
              targetH = canvasW / aspectRatio;
          }

          const offsetX = (canvasW - targetW) / 2;
          const offsetY = (canvasH - targetH) / 2;
          
          const cellWidth = targetW / numCols;
          const cellHeight = targetH / numRows;
          
          ctx.font = `bold ${cellHeight}px "Roboto Mono", monospace`;
          ctx.fillStyle = fgColor;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          for (const item of asciiData) {
              const drawX = offsetX + item.x * cellWidth + cellWidth / 2;
              const drawY = offsetY + item.y * cellHeight + cellHeight / 2;
              ctx.fillText(item.char, drawX, drawY);
          }
      }


      /**
       * Draws a frame of ASCII art to the preview canvas.
       * @param {object} frameData - The pre-processed data for the frame.
       */
      function drawAsciiFrame(frameData) {
          const ctx = outputCanvas.getContext('2d');
          if (!ctx) return;
          const bgColor = bgColorPicker.value;

          if (!frameData || !frameData.asciiData || !frameData.aspectRatio) {
              ctx.fillStyle = bgColor;
              ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
              return;
          }

          const { asciiData, numCols, numRows, aspectRatio } = frameData;
          const fgColor = fgColorPicker.value;
          
          const previewContainerWidth = outputCanvas.parentElement?.clientWidth || 800;
          outputCanvas.width = previewContainerWidth;
          outputCanvas.height = outputCanvas.width / aspectRatio;

          ctx.fillStyle = bgColor;
          ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
          
          const cellWidth = outputCanvas.width / numCols;
          const cellHeight = outputCanvas.height / numRows;
          ctx.font = `bold ${cellHeight}px "Roboto Mono", monospace`;
          ctx.fillStyle = fgColor;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          for (const item of asciiData) {
              ctx.fillText(item.char, item.x * cellWidth + cellWidth / 2, item.y * cellHeight + cellHeight / 2);
          }
      }

      function stopAnimation() {
          if (animationTimeoutId) {
              clearTimeout(animationTimeoutId);
              animationTimeoutId = null;
          }
      }

      function playAnimation() {
          stopAnimation();
          if (!isGif || asciiFrameData.length === 0) return;

          const frameData = asciiFrameData[currentFrameIndex];
          
          if (!frameData) {
              currentFrameIndex = (currentFrameIndex + 1) % asciiFrameData.length;
              animationTimeoutId = window.setTimeout(playAnimation, 100);
              return;
          }

          drawAsciiFrame(frameData.data);
          
          const delay = frameData.delay;
          currentFrameIndex = (currentFrameIndex + 1) % asciiFrameData.length;

          animationTimeoutId = window.setTimeout(playAnimation, delay);
      }

      async function processAllFrames() {
          stopAnimation();
          showProgress(true);
          controlsContainer.setAttribute('disabled', 'true');
          await new Promise(resolve => setTimeout(resolve, 20));

          asciiFrameData = [];
          const masterCanvas = document.createElement('canvas');
          const masterCtx = masterCanvas.getContext('2d');

          if (!masterCtx || !currentGif) {
              showProgress(false);
              controlsContainer.removeAttribute('disabled');
              console.error("GIF processing error: No GIF data available.");
              return;
          }

          // Set canvas to the full GIF dimensions from the logical screen descriptor
          const fullWidth = currentGif.lsd.width;
          const fullHeight = currentGif.lsd.height;
          masterCanvas.width = fullWidth;
          masterCanvas.height = fullHeight;

          for (let i = 0; i < parsedFrames.length; i++) {
              const frame = parsedFrames[i];
              const { width, height, top, left } = frame.dims;

              // Create image data for the current frame's patch
              const frameImageData = masterCtx.createImageData(width, height);
              frameImageData.data.set(frame.patch);
              
              // Draw the patch onto the master canvas at the correct offset
              // This composites the frames correctly.
              masterCtx.putImageData(frameImageData, left, top);

              // Generate ASCII from the fully composited master canvas. This prevents stretching.
              const frameGenerationResult = generateAsciiFrameData(masterCanvas);
              
              if (frameGenerationResult) {
                  asciiFrameData.push({ data: frameGenerationResult, delay: frame.delay });
              } else {
                   asciiFrameData.push({ data: null, delay: frame.delay });
              }
              
              // After processing the frame, handle its disposal to prepare the canvas for the next frame.
              // Disposal Type 2: The browser is supposed to clear the area covered by the frame to the background color.
              if (frame.disposalType === 2) {
                  masterCtx.clearRect(left, top, width, height);
              }
              // Note: Disposal type 3 (restore to previous) is not handled as it's rare and complex.
              // This implementation correctly handles the common cases.

              updateProgress(((i + 1) / parsedFrames.length) * 100);
              if (i % 5 === 0) await new Promise(resolve => setTimeout(resolve, 0));
          }
          
          showProgress(false);
          controlsContainer.removeAttribute('disabled');
          currentFrameIndex = 0;
          playAnimation();
      }


      async function generateAsciiArt() {
          if (!currentImage) return;

          const resolution = parseInt(resolutionInput.value, 10);
          const minRes = parseInt(resolutionSlider.min, 10);
          const maxRes = parseInt(resolutionSlider.max, 10);

          if (isNaN(resolution) || resolution < minRes || resolution > maxRes) {
              resolutionError.textContent = `Resolução deve ser entre ${minRes} e ${maxRes}.`;
              resolutionError.style.display = 'block';
              downloadBtn.disabled = true;
              return;
          }

          resolutionError.style.display = 'none';
          downloadBtn.disabled = false;

          if (isGif) {
              await processAllFrames();
          } else {
              showProgress(true);
              controlsContainer.setAttribute('disabled', 'true');
              await new Promise(resolve => setTimeout(resolve, 20));

              const data = generateAsciiFrameData(currentImage);
              currentAsciiData = data;
              
              updateProgress(50);
              await new Promise(resolve => setTimeout(resolve, 20));
              
              drawAsciiFrame(data);
              updateProgress(100);
              
              showProgress(false);
              controlsContainer.removeAttribute('disabled');
          }
      }


      function handleControlChange() {
          clearTimeout(debounceTimer);
          debounceTimer = window.setTimeout(generateAsciiArt, 150);
      }

      function syncResolution(source) {
          if (source === 'slider') {
              resolutionInput.value = resolutionSlider.value;
          } else {
              const value = parseInt(resolutionInput.value, 10);
              if (!isNaN(value) && value >= parseInt(resolutionSlider.min) && value <= parseInt(resolutionSlider.max)) {
                  resolutionSlider.value = value.toString();
              }
          }
      }

      function handleImageUpload(event) {
          stopAnimation();
          const target = event.target;
          const file = target.files?.[0];
          if (!file) return;

          const reader = new FileReader();
          isGif = file.type === 'image/gif';

          reader.onload = (e) => {
              uploadContainer.style.display = 'none';
              contentArea.style.display = 'grid';
              
              const img = new Image();
              img.onload = () => {
                  currentImage = img;
                  originalAspectRatio = img.naturalWidth / img.naturalHeight;
                  
                  // Set default download settings
                  downloadWidthInput.value = img.naturalWidth.toString();
                  downloadHeightInput.value = img.naturalHeight.toString();
                  const largerDimension = Math.max(img.naturalWidth, img.naturalHeight);
                  downloadSizeSlider.value = Math.min(largerDimension, parseInt(downloadSizeSlider.max)).toString();
                  presetSelect.value = 'original';
                  isAspectRatioLocked = true;
                  aspectRatioToggle.classList.add('locked');
                  aspectRatioToggle.innerHTML = ''; 

                  imagePreview.src = img.src;
                  if (isGif) {
                      const bufferReader = new FileReader();
                      bufferReader.onload = (bufEvent) => {
                          try {
                              const buffer = bufEvent.target?.result;
                              if (window.gifuct) {
                                  currentGif = window.gifuct.parseGIF(buffer);
                                  parsedFrames = window.gifuct.decompressFrames(currentGif, true);
                                  generateAsciiArt();
                              } else {
                                  console.error("gifuct-js library not loaded.");
                              }
                          } catch (err) {
                              console.error("Error processing GIF:", err);
                          }
                      };
                      bufferReader.readAsArrayBuffer(file);
                  } else {
                      currentGif = null;
                      parsedFrames = [];
                      generateAsciiArt();
                  }
              };
              img.src = e.target?.result;
          };
          reader.readAsDataURL(file);
      }

      function downloadImage() {
          if (!currentAsciiData) return;

          const downloadCanvas = document.createElement('canvas');
          downloadCanvas.width = parseInt(downloadWidthInput.value, 10) || 800;
          downloadCanvas.height = parseInt(downloadHeightInput.value, 10) || 600;

          drawAsciiToCanvas(downloadCanvas, currentAsciiData, {
              bgColor: bgColorPicker.value,
              fgColor: fgColorPicker.value,
          });
          
          const dataUrl = downloadCanvas.toDataURL('image/png');
          const link = document.createElement('a');
          link.download = 'ascii-art.png';
          link.href = dataUrl;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
      }

      async function downloadGif() {
          if (!window.GIF) {
              console.error("gif.js library not loaded.");
              return;
          }
          downloadBtn.disabled = true;
          downloadBtnText.textContent = 'Gerando GIF...';

          const gif = new window.GIF({
              workers: 2,
              quality: 10,
              workerScript: './gif.worker.js',
              background: bgColorPicker.value,
          });
          
          const downloadCanvas = document.createElement('canvas');
          downloadCanvas.width = parseInt(downloadWidthInput.value, 10) || 800;
          downloadCanvas.height = parseInt(downloadHeightInput.value, 10) || 600;

          for (const frame of asciiFrameData) {
              drawAsciiToCanvas(downloadCanvas, frame.data, {
                  bgColor: bgColorPicker.value,
                  fgColor: fgColorPicker.value,
              });
              gif.addFrame(downloadCanvas, { copy: true, delay: frame.delay });
          }

          gif.on('finished', (blob) => {
              const url = URL.createObjectURL(blob);
              const link = document.createElement('a');
              link.download = 'ascii-art.gif';
              link.href = url;
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              URL.revokeObjectURL(url);
              
              downloadBtn.disabled = false;
              downloadBtnText.textContent = 'Baixar Arte';
          });

          gif.render();
      }

      function invertColors() {
          const bg = bgColorPicker.value;
          const fg = fgColorPicker.value;
          bgColorPicker.value = fg;
          fgColorPicker.value = bg;
          generateAsciiArt();
      }

      function invertCharacters() {
          SORTED_ASCII_CHARS.reverse();
          generateAsciiArt();
      }

      function handleCharInputChange() {
          clearTimeout(charDebounceTimer);
          charDebounceTimer = window.setTimeout(async () => {
              const newChars = charInputElement.value;
              if (newChars.length < 3) return;
              
              USER_ASCII_CHARS = [...new Set(newChars.split(''))];
              charInputElement.value = USER_ASCII_CHARS.join('');

              controlsContainer.setAttribute('disabled', 'true');
              SORTED_ASCII_CHARS = await analyzeAndSortChars(USER_ASCII_CHARS);
              generateAsciiArt();
          }, 400);
      }

      function updateDownloadSlider() {
          const widthVal = parseInt(downloadWidthInput.value, 10);
          const heightVal = parseInt(downloadHeightInput.value, 10);
          if (isNaN(widthVal) || isNaN(heightVal)) return;

          const largerDimension = Math.max(widthVal, heightVal);
          downloadSizeSlider.value = Math.min(largerDimension, parseInt(downloadSizeSlider.max)).toString();
      }

      function handleDimensionChange(source) {
          if (!isAspectRatioLocked) {
              presetSelect.value = 'custom';
              updateDownloadSlider();
              return;
          }
          const widthVal = parseInt(downloadWidthInput.value, 10);
          const heightVal = parseInt(downloadHeightInput.value, 10);

          if (source === 'width' && widthVal > 0) {
              downloadHeightInput.value = Math.round(widthVal / originalAspectRatio).toString();
          } else if (source === 'height' && heightVal > 0) {
              downloadWidthInput.value = Math.round(heightVal * originalAspectRatio).toString();
          }
          presetSelect.value = 'custom';
          updateDownloadSlider();
      }

      function handlePresetChange() {
          const value = presetSelect.value;
          if (value === 'custom') {
              isAspectRatioLocked = false;
              aspectRatioToggle.classList.toggle('locked', isAspectRatioLocked);
              aspectRatioToggle.innerHTML = '';
              return;
          };

          if (value === 'original') {
              downloadWidthInput.value = currentImage?.naturalWidth.toString() || '800';
              downloadHeightInput.value = currentImage?.naturalHeight.toString() || '600';
              if (!isAspectRatioLocked) toggleAspectRatioLock();
          } else {
              const [width, height] = value.split('x');
              downloadWidthInput.value = width;
              downloadHeightInput.value = height;
          }
          updateDownloadSlider();
      }

      function handleDownloadSizeChange() {
          const size = parseInt(downloadSizeSlider.value, 10);
          let newWidth, newHeight;

          if (originalAspectRatio >= 1) { // Landscape or square
              newWidth = size;
              newHeight = Math.round(size / originalAspectRatio);
          } else { // Portrait
              newHeight = size;
              newWidth = Math.round(size * originalAspectRatio);
          }
          downloadWidthInput.value = newWidth.toString();
          downloadHeightInput.value = newHeight.toString();

          if (!isAspectRatioLocked) {
             toggleAspectRatioLock();
          }
          presetSelect.value = 'custom';
      }

      function toggleAspectRatioLock() {
          isAspectRatioLocked = !isAspectRatioLocked;
          aspectRatioToggle.classList.toggle('locked', isAspectRatioLocked);
          aspectRatioToggle.innerHTML = isAspectRatioLocked ? '' : '';
          if (isAspectRatioLocked && currentImage) {
              handleDimensionChange('width');
          }
      }

      (async () => {
          SORTED_ASCII_CHARS = await analyzeAndSortChars(USER_ASCII_CHARS);
          charInputElement.value = USER_ASCII_CHARS.join('');

          imageInputElement.addEventListener('change', handleImageUpload);
          imagePreviewBox.addEventListener('click', () => imageInputElement.click());

          resolutionSlider.addEventListener('input', () => {
              syncResolution('slider');
              handleControlChange();
          });
          resolutionInput.addEventListener('input', () => {
              syncResolution('input');
              handleControlChange();
          });

          bgColorPicker.addEventListener('input', handleControlChange);
          fgColorPicker.addEventListener('input', handleControlChange);
          
          charInputElement.addEventListener('input', handleCharInputChange);

          downloadBtn.addEventListener('click', () => isGif ? downloadGif() : downloadImage());
          invertBtn.addEventListener('click', invertColors);
          invertCharsBtn.addEventListener('click', invertCharacters);

          downloadWidthInput.addEventListener('input', () => handleDimensionChange('width'));
          downloadHeightInput.addEventListener('input', () => handleDimensionChange('height'));
          presetSelect.addEventListener('change', handlePresetChange);
          aspectRatioToggle.addEventListener('click', toggleAspectRatioLock);
          downloadSizeSlider.addEventListener('input', handleDownloadSizeChange);
      })();
    });
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>